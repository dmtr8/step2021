<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
 <!--   <style>
        #elem{
            margin: 0 auto;
            color: white;
            text-align: center;
            width: 100px;
            height: 100px;
        }
    </style>-->
</head>
<body>
<!--! Свойства узлов: тип, тег и содержимое

    EventTarget – это корневой «абстрактный» класс.
Объекты этого класса никогда не создаются.
Он служит основой, благодаря которой все DOM-узлы поддерживают «события»

    Node – также является «абстрактным» классом, и служит основой для DOM-узлов.
Он обеспечивает базовую функциональность: parentNode, nextSibling, childNodes и т.д. (это геттеры).
Объекты класса Node никогда не создаются. Но есть определённые классы узлов, которые наследуют от него:
Text – для текстовых узлов, Element – для узлов-элементов и более экзотический Comment – для узлов-комментариев.

    Element – это базовый класс для DOM-элементов.
Он обеспечивает навигацию на уровне элементов: nextElementSibling, children и методы поиска: getElementsByTagName, querySelector.
Браузер поддерживает не только HTML, но также XML и SVG.
Класс Element служит базой для следующих классов: SVGElement, XMLElement и HTMLElement.

чтобы узнать тип узла -> метод instanceof

console.log(elem) выводит элемент в виде DOM-дерева.
console.dir(elem) выводит элемент в виде DOM-объекта, что удобно для анализа его свойств.

Тег: nodeName и tagName
Свойство tagName есть только у элементов Element.
Свойство nodeName определено для любых узлов Node:
    для элементов оно равно tagName.
    для остальных типов узлов (текст, комментарий и т.д.) оно содержит строку с типом узла.
Другими словами, свойство tagName есть только у узлов-элементов (поскольку они происходят от класса Element),
а nodeName может что-то сказать о других типах узлов.
Если мы имеем дело только с элементами, то можно использовать tagName или nodeName, нет разницы.

innerHTML: содержимое элемента
Свойство innerHTML позволяет получить HTML-содержимое элемента в виде строки.
    «innerHTML+=» осуществляет перезапись:
1.Старое содержимое удаляется.
2.На его место становится новое значение innerHTML (с добавленной строкой).
Так как содержимое «обнуляется» и переписывается заново, все изображения и другие ресурсы будут перезагружены.

outerHTML: HTML элемента целиком
Свойство outerHTML содержит HTML элемента целиком. Это как innerHTML плюс сам элемент
    в отличие от innerHTML, запись в outerHTML не изменяет элемент.
Вместо этого элемент заменяется целиком во внешнем контексте.

nodeValue/data: содержимое текстового узла
Свойство innerHTML есть только у узлов-элементов.
У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства nodeValue и data.
Эти свойства очень похожи при использовании, есть лишь небольшие различия в спецификации.

textContent: просто текст
Свойство textContent предоставляет доступ к тексту внутри элемента за вычетом всех тегов

Представим, что у нас есть произвольная строка, введённая пользователем, и мы хотим показать её.
    С innerHTML вставка происходит «как HTML», со всеми HTML-тегами.
    С textContent вставка получается «как текст», все символы трактуются буквально.
(см.пример)В большинстве случаев мы рассчитываем получить от пользователя текст и хотим,
чтобы он интерпретировался как текст. Мы не хотим, чтобы на сайте появлялся произвольный HTML-код.
Присваивание через textContent – один из способов от этого защититься.

Свойство «hidden»
Атрибут и DOM-свойство «hidden» указывает на то, видим ли мы элемент или нет.
Мы можем использовать его в HTML или назначать при помощи JavaScript
Технически, hidden работает так же, как style="display:none". Но его применение проще.-->

<!--<img src="svg/new-message.svg" id="elem">-->

<!--<ul>
    <li>Животные
        <ul>
            <li>Млекопитающие
                <ul>
                    <li>Коровы</li>
                    <li>Ослы</li>
                    <li>Собаки</li>
                    <li>Тигры</li>
                </ul>
            </li>
            <li>Другие
                <ul>
                    <li>Змеи</li>
                    <li>Птицы</li>
                    <li>Ящерицы</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>Рыбы
        <ul>
            <li>Аквариумные
                <ul>
                    <li>Гуппи</li>
                    <li>Рыба-ангел</li>
                </ul>
            </li>
            <li>Морские
                <ul>
                    <li>Морская форель</li>
                </ul>
            </li>
        </ul>
    </li>
</ul>-->

<script>
   /* мигающий элемент
   let elem = document.querySelector('#elem');
    setInterval(() => elem.hidden = !elem.hidden, 1000);*/


   /*//Считаем потомковУ нас есть дерево, структурированное как вложенные списки ul/li.
   // Напишите код, который выведет каждый элемент списка <li>:
   // Какой в нём текст (без поддерева) ?
   // Какое число потомков – всех вложенных <li> (включая глубоко вложенные) ?

    for (let i of document.querySelectorAll("li")){
        //let text = li.textContent;
       // alert(li.textContent + " : " + li.children.length);
        let ii = i.querySelectorAll("li");
        alert(i.textContent + " : " + ii.length);
    }*/
    
</script>
</body>
</html>