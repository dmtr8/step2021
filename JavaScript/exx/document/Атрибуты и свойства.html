<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>dom3</title>
</head>
<body id="test" something="non-standart" non="blr">

<!--
Когда браузер загружает страницу, он «читает» (также говорят: «парсит») HTML и генерирует из него DOM-объекты.
Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов.

DOM-свойства:
можно добавлять свои
DOM-узлы – это обычные объекты JavaScript. Можно их изменять
Также можно изменять встроенные прототипы, такие как Element.prototype и добавлять новые методы ко всем элементам

HTML-атрибуты
В HTML у тегов могут быть атрибуты. Когда браузер парсит HTML, чтобы создать DOM-объекты для тегов,
он распознаёт стандартные атрибуты и создаёт DOM-свойства для них.
Таким образом, когда у элемента есть id или другой стандартный атрибут, создаётся соответствующее свойство.
Но этого не происходит, если атрибут нестандартный.
стандартный атрибут для одного тега может быть нестандартным для другого.
Таким образом, для нестандартных атрибутов не будет соответствующих DOM-свойств.
Все атрибуты доступны с помощью следующих методов:
    elem.hasAttribute(name) – проверяет наличие атрибута.
    elem.getAttribute(name) – получает значение атрибута.
    elem.setAttribute(name, value) – устанавливает значение атрибута.
    elem.removeAttribute(name) – удаляет атрибут.
Эти методы работают именно с тем, что написано в HTML.
Кроме этого, получить все атрибуты элемента можно с помощью свойства elem.attributes:
коллекция объектов, которая принадлежит ко встроенному классу Attr со свойствами name и value.
У HTML-атрибутов есть следующие особенности:
    Их имена регистроHEзависимы (id то же самое, что и ID).
    Их значения всегда являются строками.
    Все атрибуты, в том числе те, которые мы установили, видны в outerHTML.
    Коллекция attributes является перебираемой. В ней есть все атрибуты элемента (стандартные и нестандартные)
        в виде объектов со свойствами name и value.

Синхронизация между атрибутами и свойствами
Когда стандартный атрибут изменяется, соответствующее свойство автоматически обновляется.
Это работает и в обратную сторону (за некоторыми исключениями).
например, input.value синхронизируется только в одну сторону – атрибут → значение, но не в обратную

DOM-свойства типизированы
DOM-свойства не всегда являются строками. Например, свойство input.checked (для чекбоксов) имеет логический тип
Атрибут style – строка, но свойство style является объектом
Хотя большинство свойств, всё же, строки.
При этом некоторые из них, хоть и строки, могут отличаться от атрибутов.
Например, DOM-свойство href всегда содержит полный URL, даже если атрибут содержит относительный URL или просто #hash.

Нестандартные атрибуты, dataset
Иногда нестандартные атрибуты используются для передачи пользовательских данных из HTML в JavaScript,
или чтобы «помечать» HTML-элементы для JavaScript.
Также они могут быть использованы, чтобы стилизовать элементы.
.....Чтобы избежать конфликтов, существуют атрибуты вида data-*
Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами.
Они доступны в свойстве dataset.
Например, если у elem есть атрибут "data-about", то обратиться к нему можно как elem.dataset.about.





-->




























<section><div></div></section>
<p></p>
<div data-widget-name="menu">Choose the genre</div>


<script>
    let ss = document.querySelector("section");
    //console.log(ss);
    //новое свойство для section
    ss.myName = {
        name: 'Dima',
        day: '8'
    };
    //alert(ss.myName.day);

    //мeтод для div
    let dd = document.querySelector("div");
    //console.log(dd)
    dd.sayTagName = function () {
        alert(this.tagName);
    }
    //dd.sayTagName();

    //Также можно изменять встроенные прототипы, такие как Element.prototype и добавлять новые методы ко всем элементам
    Element.prototype.sayHi = function () {
        alert(`hello, I m ${this.tagName}`);
    }
    //dd.sayHi();
    //ss.sayHi();

    //стандартный и нестандартный атрибут
    //alert(document.body.id); // test
    // нестандартный атрибут не преобразуется в свойство
    //alert(document.body.something); // undefined

    //наличие атр
    //alert(document.body.hasAttribute("id"));

    //значение
    //alert(document.body.getAttribute("id"));

    //меняет значение
    //let newValAtr = document.body.setAttribute("non","hello")
    //alert(newValAtr);
    //alert(document.body.getAttribute("non"));

    //let delAtr = document.body.removeAttribute("non");
    //alert(document.body.hasAttribute("non"));

    //получение кол-вo атр.
    //alert(document.body.attributes.length);

    // alert(document.body.attributes); //[object NamedNodeMap]
    /*Интерфейс NamedNodeMap представляет собой коллекцию объектов Attr.
        Объекты внутри NamedNodeMap не находятся в каком-либо определенном порядке, в отличие от NodeList,
        хотя они могут быть доступны при использовании индекса, как в массиве.
            Объект NamedNodeMap является "живым" и, таким образом, будет автоматически обновляться,
        если изменения будут внесены в его содержимое внутри или в другом месте.*/

    //alert(document.body.attributes[2].name);


    // весь список атр
    let ddd = document.querySelector("#test");

    for (let attr of ddd.attributes) {
        //alert( `${attr.name} = ${attr.value}` );
    }

    //Напишите код для выбора элемента с атрибутом data-widget-name из документа и прочитайте его значение

  









</script>

</body>
</html>